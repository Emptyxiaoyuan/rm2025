# 遥控校准

## <code>#*define* *FLASH_WRITE_BUF_LENGHT* (sizeof(head_cali_t) + sizeof(gimbal_cali_t) + sizeof(imu_cali_t) * 3 + CALI_LIST_LENGHT * 4)</code>

计算用于存储所有校准设备（head、gimbal、gyro、accel、mag）校准数据、设备名和校准标志位所需的总字节数。

sizeof(head_cali_t)：head设备的校准数据长度（字节数）

sizeof(gimbal_cali_t)：gimbal设备的校准数据长度

sizeof(imu_cali_t) * 3：gyro、accel、mag三个设备的校准数据长度（每个设备一个imu_cali_t结构体，共3个）

CALI_LIST_LENGHT * 4：每个设备额外需要4字节（3字节设备名+1字节校准标志位），设备总数为CALI_LIST_LENGHT

这个宏定义的值就是所有设备的校准数据+设备名+校准标志位在Flash中所需的总空间（单位：字节）。

### 作用：

1. 分配写Flash的缓冲区大小
2. 写入Flash时确定写入数据的总长度
   在 `cali_data_write()` 函数中，最终写入Flash的长度就是 `FLASH_WRITE_BUF_LENGHT`

### 为什么需要：

1. 一次性批量读写：
   校准数据、设备名和标志位需要整体存入或读取自Flash。分配一个足够大的缓冲区，可以一次性将所有数据打包写入或读取，简化操作流程。
2. 保证数据完整性和一致性：
   所有设备的校准数据和标志位必须“原子性”地保存，防止部分写入或读取导致数据错乱。统一缓冲区能保证每次操作都是完整的。
3. 提高效率：
   减少多次分散的Flash操作，提升读写效率，降低Flash磨损。
4. 便于扩展和维护：
   后续如需增加设备或校准项，只需调整宏和结构体，缓冲区大小自动适配，无需手动修改多处代码

## <code>cali_id_e </code>枚举类型

用于标识区分不同的校准设备，为不同的设备分配一个唯一的编号，<code>CALI_LIST_LENGHT</code>表示总的设备数

### 主要参数

`CALI_HEAD`：头部设备的校准编号。

`CALI_GIMBAL`：云台设备的校准编号。

`CALI_GYRO`：陀螺仪设备的校准编号。

`CALI_ACC`：加速度计设备的校准编号。

`CALI_MAG`：磁力计设备的校准编号。

`CALI_LIST_LENGHT`：设备总数，用于数组长度、循环终止条件。

## <code>cali_sensor_t</code> 结构体

<code>typedef *__packed*[^__packed] struct</code>

<code>{</code>

<code> uint8_t name[3];                  *// device name*</code>

 <code>uint8_t cali_done;                 *// 0x55 means has been calibrated*</code>

 <code>uint8_t flash_len : 7;               *// buf lenght*</code>

 <code>uint8_t cali_cmd : 1;               *// 1 means to run cali hook function,*</code>

 <code>uint32_t *flash_buf;                // link to device calibration data</code>

 <code>*bool_t* (*cali_hook)(uint32_t *point, bool_t cmd); *// cali function*</code>

<code>} cali_sensor_t;</code>

描述和管理每一个需要校准的设备的校准相关信息，包括设备名，校准状态，数据缓冲区，校准函数

### 主要参数

`name[3]`设备名缩写（3字节）

`cali_done`校准完成标志。0x55即**01010101**表示该设备已经校准过，其他值表示未校准。

`flash_len` 表示当前设备校准数据在Flash中存储时的长度（以4字节即一个uint32_t为一个单位[^四字节位单位]）。

`cali_cmd`校准命令标志。为1时，表示需要对该设备执行校准流程；为0时，不需要校准。

`flash_buf`指向该设备校准数据的缓冲区指针。用于Flash读写和数据操作。

`cali_hook`设备的校准函数指针。指向具体的校准处理函数[^函数指针]（如cali_gyro_hook等），用于执行设备的校准逻辑

**因为 `cali_cmd`（校准命令标志）只需1位，所以用位域[^位域]将 `flash_len`（7位）和 `cali_cmd`（1位）合并到一个字节，节省内存空间。**

## void *calibrate_task*(void *const* *pvParameters) 

`void ()calibrate_task(void const *pvParameters){`

 `static uint8_t i = 0;`

 `calibrate_RC = get_remote_ctrl_point_cali();`

 `while (1){// 使用遥控器开始校准`

  `RC_cmd_to_calibrate();`

  `for (i = 0; i < CALI_LIST_LENGHT; i++){`

   `if (cali_sensor[i].cali_cmd){`

​    `if (cali_sensor[i].cali_hook != NULL){`

​     `if (cali_sensor[i].cali_hook(cali_sensor_buf[i], CALI_FUNC_CMD_ON)){`

​      `// done`

​      `cali_sensor[i].name[0] = cali_name[i][0];`

​      `cali_sensor[i].name[1] = cali_name[i][1];`

​      `cali_sensor[i].name[2] = cali_name[i][2];`

​      `// set 0x55`

​      `cali_sensor[i].cali_done = CALIED_FLAG;`

​      `cali_sensor[i].cali_cmd = 0;`

​      `// write`

​      `cali_data_write*();}}}}`

  `osDelay(CALIBRATE_CONTROL_TIME);`[^1ms系统延时]

`\#if INCLUDE_uxTaskGetStackHighWaterMark`

  `calibrate_task_stack = uxTaskGetStackHighWaterMark(NULL);`[^监控]

`\#endif}}`

主要校准实现函数，最表面的任务

### 主要功能：

读取遥控数据

用FreeRTOS实现遥控任务“永远实现”的独立线程，随时响应事件或处理周期性工作

调用`RC_cmd_to_calibrate()` 开始校准

对数据进行处理，同时调用`cali_data_write()`往flash中写入数据

## static void RC_cmd_to_calibrate(void)

`static void RC_cmd_to_calibrate(void){`

 `static const uint8_t BEGIN_FLAG = 1;`

 `static const uint8_t GIMBAL_FLAG = 2;`

 `static const uint8_t GYRO_FLAG = 3;`

 `static const uint8_t CHASSIS_FLAG = 4;`

 `static uint8_t i;`

 `static uint32_t rc_cmd_systemTick = 0;`

 `static uint16_t buzzer_time = 0;`

 `static uint16_t rc_cmd_time = 0;`

 `static uint8_t rc_action_flag = 0;`

 `// if something is calibrating, return*`

 `// 如果已经在校准，就返回`

 `for (i = 0; i < CALI_LIST_LENGHT; i++){`

  `if (cali_sensor[i].cali_cmd){`

   `buzzer_time = 0;`

   `rc_cmd_time = 0;`

   `rc_action_flag = 0;`

   `return;}}`

 `if (rc_action_flag == 0 && rc_cmd_time > RC_CMD_LONG_TIME){`

  `rc_cmd_systemTick = xTaskGetTickCount();`

  `rc_action_flag = BEGIN_FLAG;`

  `rc_cmd_time = 0;}`

 `else if (rc_action_flag == GIMBAL_FLAG && rc_cmd_time > RC_CMD_LONG_TIME){`

  `// 云台校准`

  `rc_action_flag = 0;`

  `rc_cmd_time = 0;`

  `cali_sensor[CALI_GIMBAL].cali_cmd = 1;`

  `cali_buzzer_off();}`

 `else if (rc_action_flag == 3 && rc_cmd_time > RC_CMD_LONG_TIME){`

  `// 陀螺仪初始化`

  `rc_action_flag = 0;`

  `rc_cmd_time = 0;`

  `cali_sensor[CALI_GYRO].cali_cmd = 1;`

  `// 更新控制温度`

  `head_cali.temperature = (int8_t)(cali_get_mcu_temperature()) + 10;`

  `if (head_cali.temperature > (int8_t)(GYRO_CONST_MAX_TEMP)){`

   `head_cali.temperature = (int8_t)(GYRO_CONST_MAX_TEMP*);}`

  `cali_buzzer_off*();}`

 `else if (rc_action_flag == CHASSIS_FLAG && rc_cmd_time > RC_CMD_LONG_TIME){`

  `rc_action_flag = 0;`

  `rc_cmd_time = 0;`

  `// 发送CAN重设ID命令到3508`

  `// CAN_cmd_chassis_reset_ID();`

  `// CAN_cmd_chassis_reset_ID();`

  `// CAN_cmd_chassis_reset_ID();`

  `// cali_buzzer_off();*}`

 `if (calibrate_RC->rc.ch[0] < -RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[1] < -RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[2] > RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[3] < -RC_CALI_VALUE_HOLE && switch_is_down(calibrate_RC->rc.s[0]) && switch_is_down(calibrate_RC->rc.s[1]) && rc_action_flag == 0) {`

  `// 两个摇杆打成 \../,保持2s`

  `rc_cmd_time++;}`

 `else if (calibrate_RC->rc.ch[0] > RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[1] > RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[2] < -RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[3] > RC_CALI_VALUE_HOLE && switch_is_down(calibrate_RC->rc.s[0]) && switch_is_down(calibrate_RC->rc.s[1]) && rc_action_flag != 0){`

  `// 两个摇杆打成'\/',保持2s`

  `rc_cmd_time++;`

  `rc_action_flag = GIMBAL_FLAG;}` 

 `else if (calibrate_RC->rc.ch[0] > RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[1] < -RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[2] < -RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[3] < -RC_CALI_VALUE_HOLE && switch_is_down(calibrate_RC->rc.s[0]) && switch_is_down(calibrate_RC->rc.s[1]) && rc_action_flag != 0){`

  `// 两个摇杆打成./\.,保持2s`

  `rc_cmd_time++;`

  `rc_action_flag = GYRO_FLAG;}`

 `else if (calibrate_RC->rc.ch[0] < -RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[1] > RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[2] > RC_CALI_VALUE_HOLE && calibrate_RC->rc.ch[3] > RC_CALI_VALUE_HOLE && switch_is_down(calibrate_RC->rc.s[0]) && switch_is_down(calibrate_RC->rc.s[1]) && rc_action_flag != 0){`

  `// 两个摇杆打成/''\,保持2s`

  `// 电机校准(设置ID) 不需要`[^不需要设置ID]

  `// rc_cmd_time++;`

  `// rc_action_flag = CHASSIS_FLAG;*}`

 `else{`

  `rc_cmd_time = 0; }`

 `calibrate_systemTick = xTaskGetTickCount();`

 `if (calibrate_systemTick - rc_cmd_systemTick > CALIBRATE_END_TIME){`

  `// 超过20s,停止`

  `rc_action_flag = 0;`

  `return;}`

 `else if (calibrate_systemTick - rc_cmd_systemTick > RC_CALI_BUZZER_MIDDLE_TIME && rc_cmd_systemTick != 0 && rc_action_flag != 0){`

  `rc_cali_buzzer_middle_on();}`

 `else if (calibrate_systemTick - rc_cmd_systemTick > 0 && rc_cmd_systemTick != 0 && rc_action_flag != 0){`

  `rc_cali_buzzer_start_on();`

 `}if (rc_action_flag != 0){`

  `buzzer_time++;}`

`if (buzzer_time > RCCALI_BUZZER_CYCLE_TIME && rc_action_flag != 0){`

  `buzzer_time = 0;}`

 `if (buzzer_time > RC_CALI_BUZZER_PAUSE_TIME && rc_action_flag != 0) {`

`cali_buzzer_off();}}`

是一个静态函数，用于通过遥控器的特定操作（摇杆和开关组合）来触发不同设备（如陀螺仪、云台、底盘）的校准流程。

### 主要功能：

监听遥控器输入，判断是否进行了特定的“校准手势”。

不同的手势，设置对应设备的校准命令

控制蜂鸣器提示校准状态。

限定校准操作的时间窗口，超时自动退出校准模式。

### 主要参数

`BEGIN_FLAG`、`GIMBAL_FLAG`、`GYRO_FLAG`、`CHASSIS_FLAG`：用于标记当前校准流程的阶段或类型。

`rc_cmd_systemTick`：记录校准流程开始的系统时间戳。

`buzzer_time`：蜂鸣器计时，用于控制蜂鸣器的提示节奏。

`rc_cmd_time`：校准手势保持时间计数，用于判断用户是否持续做出校准动作。

`rc_action_flag`：当前校准动作的状态标志，决定后续流程。

0：未进入校准流程

1：已进入校准流程

2/3/4：分别代表云台、陀螺仪、底盘等不同校准动作的阶段

## *static* void *cali_data_write*(void)

`static void cali_data_write(void){`

 `uint8_t i = 0;`

 `uint16_t offset = 0;`

 `for (i = 0; i < CALI_LIST_LENGHT; i++){`

  `// copy the data of device calibration data`

  `memcpy((void *)(flash_write_buf + offset), (void *)cali_sensor[i].flash_buf, cali_sensor[i].flash_len * 4);`

  `offset += cali_sensor[i].flash_len * 4;`

  `// copy the name and "CALI_FLAG" of device`

  `memcpy((void *)(flash_write_buf + offset), (void *)cali_sensor[i].name, CALI_SENSOR_HEAD_LEGHT * 4);`

  `offset += CALI_SENSOR_HEAD_LEGHT * 4;}`

 `// erase the page`

 `cali_flash_erase(FLASH_USER_ADDR, 1);`

 `// write data`

 `cali_flash_write(FLASH_USER_ADDR, (uint32_t )flash_write_buf, (FLASH_WRITE_BUF_LENGHT + 3) / 4);}`[^+3]

### 主要功能：

往flash写入校准数据

将所有设备的校准数据、设备名和校准标志位，依次打包到一个连续的缓冲区（flash_write_buf）

擦除缓冲区数据

一次性打包写入flash

## *static* bool_t *cali_head_hook*(uint32_t *cali, bool_t cmd)

`static bool_t cali_head_hook(uint32_t *cali, bool_t cmd){`

 `head_cali_t *local_cali_t = (head_cali_t *)cali;`

 `if (cmd == CALI_FUNC_CMD_INIT*){`

  `//     memcpy(&head_cali, local_cali_t, sizeof(head_cali_t));`

  `return 1; }`

 `// self id`

 `local_cali_t->self_id = SELF_ID;`

 `// imu control temperature`

 `local_cali_t->temperature = (int8_t)(*cali_get_mcu_temperature()) + 10;`[^+10]

 `// head_cali.temperature = (int8_t)(cali_get_mcu_temperature()) + 10;`

 `if (local_cali_t->temperature > (int8_t)(GYRO_CONST_MAX_TEMP)){`

  `local_cali_t->temperature = (int8_t)(GYRO_CONST_MAX_TEMP*);}`

 `local_cali_t->firmware_version = FIRMWARE_VERSION*;`

 `// shenzhen latitude`

 `local_cali_t->latitude = 22.0f;`

 `return 1;}`

### 主要功能：

在初始化时恢复head设备的校准参数；

在校准时为head设备写入新的校准数据（如温度、ID、固件版本、默认纬度等），并返回校准完成状态。

# 遥控器

## `uint8_t RC_data_is_error(void)`

`uint8_t RC_data_is_error (void){`

 `// 使用了go to语句 方便出错统一处理遥控器变量数据归零*`[^goto]

 `if (RC_abs*(rc_ctrl.rc.ch[0]) > RC_CHANNAL_ERROR_VALUE){`

  `goto error;}`

 `if (RC_abs(rc_ctrl.rc.ch[1]) > RC_CHANNAL_ERROR_VALUE){`

  `goto error; }`

 `if (RC_abs(rc_ctrl.rc.ch[2]) > RC_CHANNAL_ERROR_VALUE){`

  `goto error;}`

 `if (RC_abs(rc_ctrl.rc.ch[3]) > RC_CHANNAL_ERROR_VALUE){`

  `goto error;}`

 `if (rc_ctrl.rc.s[0] == 0){`

  `goto error;}`

 `if (rc_ctrl.rc.s[1] == 0){`

  `goto error; }`

 `return 0;`

`// go to 语句跳转`

`error:`

 `rc_ctrl.rc.ch[0] = 0;`

 `rc_ctrl.rc.ch[1] = 0;`

 `rc_ctrl.rc.ch[2] = 0;`

 `rc_ctrl.rc.ch[3] = 0;`

 `rc_ctrl.rc.ch[4] = 0;`

 `rc_ctrl.rc.s[0] = RC_SW_DOWN;`

 `rc_ctrl.rc.s[1] = RC_SW_DOWN;`

 `rc_ctrl.mouse.x = 0;`

 `rc_ctrl.mouse.y = 0;`

 `rc_ctrl.mouse.z = 0;`

 `rc_ctrl.mouse.press_l = 0;`

 `rc_ctrl.mouse.press_r = 0;`

 `rc_ctrl.key.v = 0;`

 `return 1;}`

### void *USART3_IRQHandler*(void)

void USART3_IRQHandler(void){

 if (huart3.Instance->SR & UART_FLAG_RXNE) // 接收到数据{

  __HAL_UART_CLEAR_PEFLAG(&huart3);}

 else if (USART3->SR & UART_FLAG_IDLE){

  static uint16_t this_time_rx_len = 0;

  __HAL_UART_CLEAR_PEFLAG(&huart3);

  if ((hdma_usart3_rx.Instance->CR & DMA_SxCR_CT) == RESET){

   Current memory buffer used is Memory 0 

   // disable DMA

   // 失效DMA

   __HAL_DMA_DISABLE(&hdma_usart3_rx);

   // get receive data length, length = set_data_length - remain_length

   // 获取接收数据长度,长度 = 设定长度 - 剩余长度

   this_time_rx_len = SBUS_RX_BUF_NUM - hdma_usart3_rx.Instance->NDTR;

   // reset set_data_lenght

   // 重新设定数据长度

   hdma_usart3_rx.Instance->NDTR = SBUS_RX_BUF_NUM;

   // set memory buffer 1

   // 设定缓冲区1

   hdma_usart3_rx.Instance->CR |= DMA_SxCR_CT;

   // enable DMA

   // 使能DMA

   __HAL_DMA_ENABLE(&hdma_usart3_rx);

   if (this_time_rx_len == RC_FRAME_LENGTH){

​    sbus_to_rc(sbus_rx_buf[0], &rc_ctrl);

​    // 记录数据接收时间

​    detect_hook(DBUS_TOE);

​    sbus_to_usart1(sbus_rx_buf[0]);}}

  else{

   /\* Current memory buffer used is Memory 1 \*/

   // 失效DMA

   __HAL_DMA_DISABLE(&hdma_usart3_rx);

   // 获取接收数据长度,长度 = 设定长度 - 剩余长度

   this_time_rx_len = SBUS_RX_BUF_NUM - hdma_usart3_rx.Instance->NDTR;

   // 重新设定数据长度

   hdma_usart3_rx.Instance->NDTR = SBUS_RX_BUF_NUM;

   // 设定缓冲区0

   DMA1_Stream1->CR &= ~(DMA_SxCR_CT);

   // 使能DMA

   __HAL_DMA_ENABLE(&hdma_usart3_rx);

   if (this_time_rx_len == RC_FRAME_LENGTH){

​    // 处理遥控器数据

​    sbus_to_rc(sbus_rx_buf[1], &rc_ctrl);

​    // 记录数据接收时间

​    detect_hook(DBUS_TOE);

​    sbus_to_usart1(sbus_rx_buf[1]);}}}}



[^四字节位单位]: STM32等嵌入式芯片的Flash通常以32位（4字节）为最小读写/擦除单位，按4字节对齐能保证Flash操作的效率和可靠性，结构体指针（如`uint32_t *flash_buf`）和大多数校准数据本身就是以4字节（`uint32_t`或`float`）为基本单元，便于直接读写和类型转换，以4字节为单位可以节省空间（用一个`uint8_t`就能表示最大255×4=1020字节），同时简化代码逻辑，避免字节对齐和越界问题。

[^位域]: C语言中的位域可以用于对结构体成员进行位级别的控制和优化。其定义、特点及使用方法详见 [C 位域 | 菜鸟教程](https://www.runoob.com/cprogramming/c-bit-fields.html)

[^函数指针]: 为什么能指向具体的校准处理函数？因为 C 语言的函数指针本质上就是一个“指向函数入口地址的变量”。 只要某个函数的声明（参数和返回值类型）与这个指针类型一致，就可以把它的地址赋值给这个指针。
[^__packed]: 是结构体前的一个修饰符（通常是编译器扩展），它的作用是让结构体中的成员“紧凑排列”，不进行字节对齐填充。**默认情况下**，C 结构体的成员会按类型自动对齐（如4字节对齐），可能会在成员之间插入填充字节，导致结构体实际大小大于所有成员之和。**加了 `__packed`**，编译器会取消自动对齐，所有成员紧密排列，结构体大小就是所有成员字节数之和，没有多余的填充字节。典型用途用于和硬件寄存器、通信协议、Flash存储等“定长、定格式”数据打交道时，保证结构体内存布局和实际数据格式完全一致，防止因对齐导致数据错位或浪费空间。
[^监控]: 这段代码的作用是**监控当前任务的堆栈（stack）使用情况**，用于调试和优化RTOS任务的内存分配
[^1ms系统延时]: **防止CPU占用过高** 如果没有延时，任务会一直高速循环，占满CPU，导致系统其他任务无法正常调度，影响整个RTOS系统的实时性和稳定性。**保证任务调度公平** 1ms延时让出CPU时间片，允许其他任务（如传感器采集、通信、控制等）有机会运行，实现多任务系统的正常轮转。**降低功耗** 适当延时可以让MCU进入低功耗状态（如空闲、睡眠），减少不必要的能耗。**满足校准流程的时间需求** 校准流程（如检测遥控器动作、蜂鸣器控制等）本身不需要毫秒级高速刷新，1ms的刷新周期足够灵敏，也便于实现如“保持2秒”等时间判断。1ms系统延时是嵌入式多任务系统的常规做法，既保证了任务的实时性，又避免了CPU资源浪费和系统卡死。
[^不需要设置ID]: **底盘电机ID校准不是必须流程** 对于大多数底盘，电机ID一般在出厂时已经设定好，正常使用过程中很少需要频繁更改ID。相比陀螺仪和云台的零点/偏置校准，ID校准的需求极低。**安全性和误操作考虑** 电机ID校准如果误触发，可能导致底盘电机ID被重置，影响整车运动控制，后果严重。因此，开发者通常会把这部分功能屏蔽或只在特殊维护模式下开放，防止用户误操作。**代码结构预留扩展** 这段代码保留了手势识别的入口（即判断/''\姿态），但实际功能被注释掉，方便后续如果有需求可以快速恢复或扩展底盘ID校准功能。**注释说明** 代码中明确写了“电机校准(设置ID) 不需要”，说明当前版本不需要底盘ID校准，属于有意为之。这一段只是预留了底盘ID校准的手势识别，但实际功能被注释掉，是出于安全、实际需求和代码可维护性考虑。只有陀螺仪和云台校准是常用且必须的，底盘ID校准一般不开放给普通用户。
[^+3]: `FLASH_WRITE_BUF_LENGHT` 表示需要写入的总字节数（单位：字节）。`cali_flash_write` 的第三个参数要求的是“写入多少个uint32_t”（每个4字节）。如果`FLASH_WRITE_BUF_LENGHT`不是4的整数倍，直接除以4会丢掉不足4字节的部分，导致最后几个字节不会被写入。加3的作用是：只要有多余的1~3个字节，除法结果就会向上进1，保证所有数据都能被写入。

[^+10]: 片内温度传感器测得的是MCU（单片机）本身的温度，而IMU的理想工作温度通常比环境温度高一些，这样可以减少温漂，提高陀螺仪等传感器的精度和稳定性。通过加10度，设定一个比当前MCU温度更高的目标温度，后续加热或温控模块会以这个温度为目标进行加热控制。这样做的好处是：即使环境温度较低，IMU也能被加热到一个更适合工作的温度区间，提升传感器一致性和可靠性。



[^goto]: `goto`语句是C语言中的一种**无条件跳转语句**，它可以让程序直接跳转到同一函数内的某个标签位置继续执行。**简化错误处理流程**，避免多层嵌套或重复代码。但**不建议滥用**，因为会让代码流程变得不清晰，维护困难。一般只在错误处理、资源释放等场景下使用。
